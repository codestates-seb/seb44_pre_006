{"ast":null,"code":"import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/),\n    result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (mac) meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\nfunction normalize(map) {\n  let copy = Object.create(null);\n  for (let prop in map) copy[normalizeKeyName(prop)] = map[prop];\n  return copy;\n}\nfunction modifiers(name, event) {\n  let shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`â€”a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n  return new Plugin({\n    props: {\n      handleKeyDown: keydownHandler(bindings)\n    }\n  });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n  let map = normalize(bindings);\n  return function (view, event) {\n    let name = keyName(event),\n      baseName,\n      direct = map[modifiers(name, event)];\n    if (direct && direct(view.state, view.dispatch, view)) return true;\n    // A character key\n    if (name.length == 1 && name != \" \") {\n      if (event.shiftKey) {\n        // In case the name was already modified by shift, try looking\n        // it up without its shift modifier\n        let noShift = map[modifiers(name, event, false)];\n        if (noShift && noShift(view.state, view.dispatch, view)) return true;\n      }\n      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {\n        // Try falling back to the keyCode when there's a modifier\n        // active or the character produced isn't ASCII, and our table\n        // produces a different name from the the keyCode. See #668,\n        // #1060\n        let fromCode = map[modifiers(baseName, event)];\n        if (fromCode && fromCode(view.state, view.dispatch, view)) return true;\n      }\n    }\n    return false;\n  };\n}\nexport { keydownHandler, keymap };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}