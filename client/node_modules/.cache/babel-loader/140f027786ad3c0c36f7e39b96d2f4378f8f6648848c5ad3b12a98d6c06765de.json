{"ast":null,"code":"import _get from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\nvar classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nvar Selection = /*#__PURE__*/function () {\n  /**\n  Initialize a selection with the head and anchor and ranges. If no\n  ranges are given, constructs a single range across `$anchor` and\n  `$head`.\n  */\n  function Selection(\n  /**\n  The resolved anchor of the selection (the side that stays in\n  place when the selection is modified).\n  */\n  $anchor,\n  /**\n  The resolved head of the selection (the side that moves when\n  the selection is modified).\n  */\n  $head, ranges) {\n    _classCallCheck(this, Selection);\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  /**\n  The selection's anchor, as an unresolved position.\n  */\n  _createClass(Selection, [{\n    key: \"anchor\",\n    get: function get() {\n      return this.$anchor.pos;\n    }\n    /**\n    The selection's head.\n    */\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.$head.pos;\n    }\n    /**\n    The lower bound of the selection's main range.\n    */\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.$from.pos;\n    }\n    /**\n    The upper bound of the selection's main range.\n    */\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.$to.pos;\n    }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n  }, {\n    key: \"$from\",\n    get: function get() {\n      return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n  }, {\n    key: \"$to\",\n    get: function get() {\n      return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n  }, {\n    key: \"empty\",\n    get: function get() {\n      var ranges = this.ranges;\n      for (var i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;\n      return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n  }, {\n    key: \"content\",\n    value: function content() {\n      return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n      // Put the new selection at the position after the inserted\n      // content. When that ended in an inline node, search backwards,\n      // to get the position after that node. If not, search forward.\n      var lastNode = content.content.lastChild,\n        lastParent = null;\n      for (var i = 0; i < content.openEnd; i++) {\n        lastParent = lastNode;\n        lastNode = lastNode.lastChild;\n      }\n      var mapFrom = tr.steps.length,\n        ranges = this.ranges;\n      for (var _i = 0; _i < ranges.length; _i++) {\n        var _ranges$_i = ranges[_i],\n          $from = _ranges$_i.$from,\n          $to = _ranges$_i.$to,\n          mapping = tr.mapping.slice(mapFrom);\n        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? Slice.empty : content);\n        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n      }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(tr, node) {\n      var mapFrom = tr.steps.length,\n        ranges = this.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var _ranges$i = ranges[i],\n          $from = _ranges$i.$from,\n          $to = _ranges$i.$to,\n          mapping = tr.mapping.slice(mapFrom);\n        var from = mapping.map($from.pos),\n          to = mapping.map($to.pos);\n        if (i) {\n          tr.deleteRange(from, to);\n        } else {\n          tr.replaceRangeWith(from, to, node);\n          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n        }\n      }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n  }, {\n    key: \"getBookmark\",\n    value:\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    function getBookmark() {\n      return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n  }], [{\n    key: \"findFrom\",\n    value: function findFrom($pos, dir) {\n      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n      if (inner) return inner;\n      for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n        if (found) return found;\n      }\n      return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n  }, {\n    key: \"near\",\n    value: function near($pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n  }, {\n    key: \"atStart\",\n    value: function atStart(doc) {\n      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n  }, {\n    key: \"atEnd\",\n    value: function atEnd(doc) {\n      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\");\n      var cls = classesById[json.type];\n      if (!cls) throw new RangeError(\"No selection type \".concat(json.type, \" defined\"));\n      return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, selectionClass) {\n      if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n      classesById[id] = selectionClass;\n      selectionClass.prototype.jsonID = id;\n      return selectionClass;\n    }\n  }]);\n  return Selection;\n}();\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nvar SelectionRange = /*#__PURE__*/_createClass(\n/**\nCreate a range.\n*/\nfunction SelectionRange(\n/**\nThe lower bound of the range.\n*/\n$from,\n/**\nThe upper bound of the range.\n*/\n$to) {\n  _classCallCheck(this, SelectionRange);\n  this.$from = $from;\n  this.$to = $to;\n});\nvar warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nvar TextSelection = /*#__PURE__*/function (_Selection) {\n  _inherits(TextSelection, _Selection);\n  var _super = _createSuper(TextSelection);\n  /**\n  Construct a text selection between the given points.\n  */\n  function TextSelection($anchor) {\n    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;\n    _classCallCheck(this, TextSelection);\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    return _super.call(this, $anchor, $head);\n  }\n  /**\n  Returns a resolved position if this is a cursor selection (an\n  empty text selection), and null otherwise.\n  */\n  _createClass(TextSelection, [{\n    key: \"$cursor\",\n    get: function get() {\n      return this.$anchor.pos == this.$head.pos ? this.$head : null;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $head = doc.resolve(mapping.map(this.head));\n      if (!$head.parent.inlineContent) return Selection.near($head);\n      var $anchor = doc.resolve(mapping.map(this.anchor));\n      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n      _get(_getPrototypeOf(TextSelection.prototype), \"replace\", this).call(this, tr, content);\n      if (content == Slice.empty) {\n        var marks = this.$from.marksAcross(this.$to);\n        if (marks) tr.ensureMarks(marks);\n      }\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new TextBookmark(this.anchor, this.head);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"text\",\n        anchor: this.anchor,\n        head: this.head\n      };\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n  }, {\n    key: \"create\",\n    value: function create(doc, anchor) {\n      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;\n      var $anchor = doc.resolve(anchor);\n      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n  }, {\n    key: \"between\",\n    value: function between($anchor, $head, bias) {\n      var dPos = $anchor.pos - $head.pos;\n      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;\n      if (!$head.parent.inlineContent) {\n        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n        if (found) $head = found.$head;else return Selection.near($head, bias);\n      }\n      if (!$anchor.parent.inlineContent) {\n        if (dPos == 0) {\n          $anchor = $head;\n        } else {\n          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;\n        }\n      }\n      return new TextSelection($anchor, $head);\n    }\n  }]);\n  return TextSelection;\n}(Selection);\nSelection.jsonID(\"text\", TextSelection);\nvar TextBookmark = /*#__PURE__*/function () {\n  function TextBookmark(anchor, head) {\n    _classCallCheck(this, TextBookmark);\n    this.anchor = anchor;\n    this.head = head;\n  }\n  _createClass(TextBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n  }]);\n  return TextBookmark;\n}();\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nvar NodeSelection = /*#__PURE__*/function (_Selection2) {\n  _inherits(NodeSelection, _Selection2);\n  var _super2 = _createSuper(NodeSelection);\n  /**\n  Create a node selection. Does not verify the validity of its\n  argument.\n  */\n  function NodeSelection($pos) {\n    var _this;\n    _classCallCheck(this, NodeSelection);\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    _this = _super2.call(this, $pos, $end);\n    _this.node = node;\n    return _this;\n  }\n  _createClass(NodeSelection, [{\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var _mapping$mapResult = mapping.mapResult(this.anchor),\n        deleted = _mapping$mapResult.deleted,\n        pos = _mapping$mapResult.pos;\n      var $pos = doc.resolve(pos);\n      if (deleted) return Selection.near($pos);\n      return new NodeSelection($pos);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return new Slice(Fragment.from(this.node), 0, 0);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"node\",\n        anchor: this.anchor\n      };\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new NodeBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\") throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n      return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n  }, {\n    key: \"create\",\n    value: function create(doc, from) {\n      return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n  }, {\n    key: \"isSelectable\",\n    value: function isSelectable(node) {\n      return !node.isText && node.type.spec.selectable !== false;\n    }\n  }]);\n  return NodeSelection;\n}(Selection);\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nvar NodeBookmark = /*#__PURE__*/function () {\n  function NodeBookmark(anchor) {\n    _classCallCheck(this, NodeBookmark);\n    this.anchor = anchor;\n  }\n  _createClass(NodeBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      var _mapping$mapResult2 = mapping.mapResult(this.anchor),\n        deleted = _mapping$mapResult2.deleted,\n        pos = _mapping$mapResult2.pos;\n      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var $pos = doc.resolve(this.anchor),\n        node = $pos.nodeAfter;\n      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);\n      return Selection.near($pos);\n    }\n  }]);\n  return NodeBookmark;\n}();\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nvar AllSelection = /*#__PURE__*/function (_Selection3) {\n  _inherits(AllSelection, _Selection3);\n  var _super3 = _createSuper(AllSelection);\n  /**\n  Create an all-selection over the given document.\n  */\n  function AllSelection(doc) {\n    _classCallCheck(this, AllSelection);\n    return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n  _createClass(AllSelection, [{\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n      if (content == Slice.empty) {\n        tr.delete(0, tr.doc.content.size);\n        var sel = Selection.atStart(tr.doc);\n        if (!sel.eq(tr.selection)) tr.setSelection(sel);\n      } else {\n        _get(_getPrototypeOf(AllSelection.prototype), \"replace\", this).call(this, tr, content);\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"all\"\n      };\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"map\",\n    value: function map(doc) {\n      return new AllSelection(doc);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof AllSelection;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return AllBookmark;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc) {\n      return new AllSelection(doc);\n    }\n  }]);\n  return AllSelection;\n}(Selection);\nSelection.jsonID(\"all\", AllSelection);\nvar AllBookmark = {\n  map: function map() {\n    return this;\n  },\n  resolve: function resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir) {\n  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (node.inlineContent) return TextSelection.create(doc, pos);\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) return;\n  var step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return;\n  var map = tr.mapping.maps[last],\n    end;\n  map.forEach(function (_from, _to, _newFrom, newTo) {\n    if (end == null) end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nvar UPDATED_SEL = 1,\n  UPDATED_MARKS = 2,\n  UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nvar Transaction = /*#__PURE__*/function (_Transform) {\n  _inherits(Transaction, _Transform);\n  var _super4 = _createSuper(Transaction);\n  /**\n  @internal\n  */\n  function Transaction(state) {\n    var _this2;\n    _classCallCheck(this, Transaction);\n    _this2 = _super4.call(this, state.doc);\n    // The step count for which the current selection is valid.\n    _this2.curSelectionFor = 0;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    _this2.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    _this2.meta = Object.create(null);\n    _this2.time = Date.now();\n    _this2.curSelection = state.selection;\n    _this2.storedMarks = state.storedMarks;\n    return _this2;\n  }\n  /**\n  The transaction's current selection. This defaults to the editor\n  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n  transaction, but can be overwritten with\n  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n  */\n  _createClass(Transaction, [{\n    key: \"selection\",\n    get: function get() {\n      if (this.curSelectionFor < this.steps.length) {\n        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n        this.curSelectionFor = this.steps.length;\n      }\n      return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      if (selection.$from.doc != this.doc) throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n      this.curSelection = selection;\n      this.curSelectionFor = this.steps.length;\n      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n      this.storedMarks = null;\n      return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n  }, {\n    key: \"selectionSet\",\n    get: function get() {\n      return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n  }, {\n    key: \"setStoredMarks\",\n    value: function setStoredMarks(marks) {\n      this.storedMarks = marks;\n      this.updated |= UPDATED_MARKS;\n      return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n  }, {\n    key: \"ensureMarks\",\n    value: function ensureMarks(marks) {\n      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);\n      return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n  }, {\n    key: \"addStoredMark\",\n    value: function addStoredMark(mark) {\n      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n  }, {\n    key: \"removeStoredMark\",\n    value: function removeStoredMark(mark) {\n      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n  }, {\n    key: \"storedMarksSet\",\n    get: function get() {\n      return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      _get(_getPrototypeOf(Transaction.prototype), \"addStep\", this).call(this, step, doc);\n      this.updated = this.updated & ~UPDATED_MARKS;\n      this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.time = time;\n      return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(slice) {\n      this.selection.replace(this, slice);\n      return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n  }, {\n    key: \"replaceSelectionWith\",\n    value: function replaceSelectionWith(node) {\n      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var selection = this.selection;\n      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));\n      selection.replaceWith(this, node);\n      return this;\n    }\n    /**\n    Delete the selection.\n    */\n  }, {\n    key: \"deleteSelection\",\n    value: function deleteSelection() {\n      this.selection.replace(this);\n      return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n  }, {\n    key: \"insertText\",\n    value: function insertText(text, from, to) {\n      var schema = this.doc.type.schema;\n      if (from == null) {\n        if (!text) return this.deleteSelection();\n        return this.replaceSelectionWith(schema.text(text), true);\n      } else {\n        if (to == null) to = from;\n        to = to == null ? from : to;\n        if (!text) return this.deleteRange(from, to);\n        var marks = this.storedMarks;\n        if (!marks) {\n          var $from = this.doc.resolve(from);\n          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n        }\n        this.replaceRangeWith(from, to, schema.text(text, marks));\n        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));\n        return this;\n      }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(key, value) {\n      this.meta[typeof key == \"string\" ? key : key.key] = value;\n      return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n  }, {\n    key: \"getMeta\",\n    value: function getMeta(key) {\n      return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n  }, {\n    key: \"isGeneric\",\n    get: function get() {\n      for (var _ in this.meta) return false;\n      return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      this.updated |= UPDATED_SCROLL;\n      return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n  }, {\n    key: \"scrolledIntoView\",\n    get: function get() {\n      return (this.updated & UPDATED_SCROLL) > 0;\n    }\n  }]);\n  return Transaction;\n}(Transform);\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\nvar FieldDesc = /*#__PURE__*/_createClass(function FieldDesc(name, desc, self) {\n  _classCallCheck(this, FieldDesc);\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n});\nvar baseFields = [new FieldDesc(\"doc\", {\n  init: function init(config) {\n    return config.doc || config.schema.topNodeType.createAndFill();\n  },\n  apply: function apply(tr) {\n    return tr.doc;\n  }\n}), new FieldDesc(\"selection\", {\n  init: function init(config, instance) {\n    return config.selection || Selection.atStart(instance.doc);\n  },\n  apply: function apply(tr) {\n    return tr.selection;\n  }\n}), new FieldDesc(\"storedMarks\", {\n  init: function init(config) {\n    return config.storedMarks || null;\n  },\n  apply: function apply(tr, _marks, _old, state) {\n    return state.selection.$cursor ? tr.storedMarks : null;\n  }\n}), new FieldDesc(\"scrollToSelection\", {\n  init: function init() {\n    return 0;\n  },\n  apply: function apply(tr, prev) {\n    return tr.scrolledIntoView ? prev + 1 : prev;\n  }\n})];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nvar Configuration = /*#__PURE__*/_createClass(function Configuration(schema, plugins) {\n  var _this3 = this;\n  _classCallCheck(this, Configuration);\n  this.schema = schema;\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  this.fields = baseFields.slice();\n  if (plugins) plugins.forEach(function (plugin) {\n    if (_this3.pluginsByKey[plugin.key]) throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n    _this3.plugins.push(plugin);\n    _this3.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n  });\n});\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nvar EditorState = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function EditorState(\n  /**\n  @internal\n  */\n  config) {\n    _classCallCheck(this, EditorState);\n    this.config = config;\n  }\n  /**\n  The schema of the state's document.\n  */\n  _createClass(EditorState, [{\n    key: \"schema\",\n    get: function get() {\n      return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n  }, {\n    key: \"apply\",\n    value: function apply(tr) {\n      return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"filterTransaction\",\n    value: function filterTransaction(tr) {\n      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      for (var i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n        var plugin = this.config.plugins[i];\n        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;\n      }\n      return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n  }, {\n    key: \"applyTransaction\",\n    value: function applyTransaction(rootTr) {\n      if (!this.filterTransaction(rootTr)) return {\n        state: this,\n        transactions: []\n      };\n      var trs = [rootTr],\n        newState = this.applyInner(rootTr),\n        seen = null;\n      // This loop repeatedly gives plugins a chance to respond to\n      // transactions as new transactions are added, making sure to only\n      // pass the transactions the plugin did not see before.\n      for (;;) {\n        var haveNew = false;\n        for (var i = 0; i < this.config.plugins.length; i++) {\n          var plugin = this.config.plugins[i];\n          if (plugin.spec.appendTransaction) {\n            var n = seen ? seen[i].n : 0,\n              oldState = seen ? seen[i].state : this;\n            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n            if (tr && newState.filterTransaction(tr, i)) {\n              tr.setMeta(\"appendedTransaction\", rootTr);\n              if (!seen) {\n                seen = [];\n                for (var j = 0; j < this.config.plugins.length; j++) seen.push(j < i ? {\n                  state: newState,\n                  n: trs.length\n                } : {\n                  state: this,\n                  n: 0\n                });\n              }\n              trs.push(tr);\n              newState = newState.applyInner(tr);\n              haveNew = true;\n            }\n            if (seen) seen[i] = {\n              state: newState,\n              n: trs.length\n            };\n          }\n        }\n        if (!haveNew) return {\n          state: newState,\n          transactions: trs\n        };\n      }\n    }\n    /**\n    @internal\n    */\n  }, {\n    key: \"applyInner\",\n    value: function applyInner(tr) {\n      if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\");\n      var newInstance = new EditorState(this.config),\n        fields = this.config.fields;\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n      }\n      return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n  }, {\n    key: \"tr\",\n    get: function get() {\n      return new Transaction(this);\n    }\n    /**\n    Create a new state.\n    */\n  }, {\n    key: \"reconfigure\",\n    value:\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    function reconfigure(config) {\n      var $config = new Configuration(this.schema, config.plugins);\n      var fields = $config.fields,\n        instance = new EditorState($config);\n      for (var i = 0; i < fields.length; i++) {\n        var name = fields[i].name;\n        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n      }\n      return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pluginFields) {\n      var result = {\n        doc: this.doc.toJSON(),\n        selection: this.selection.toJSON()\n      };\n      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {\n        return m.toJSON();\n      });\n      if (pluginFields && typeof pluginFields == 'object') for (var prop in pluginFields) {\n        if (prop == \"doc\" || prop == \"selection\") throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n        var plugin = pluginFields[prop],\n          state = plugin.spec.state;\n        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n      }\n      return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n  }], [{\n    key: \"create\",\n    value: function create(config) {\n      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n      var instance = new EditorState($config);\n      for (var i = 0; i < $config.fields.length; i++) instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n      return instance;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(config, json, pluginFields) {\n      if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n      if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\");\n      var $config = new Configuration(config.schema, config.plugins);\n      var instance = new EditorState($config);\n      $config.fields.forEach(function (field) {\n        if (field.name == \"doc\") {\n          instance.doc = Node.fromJSON(config.schema, json.doc);\n        } else if (field.name == \"selection\") {\n          instance.selection = Selection.fromJSON(instance.doc, json.selection);\n        } else if (field.name == \"storedMarks\") {\n          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n        } else {\n          if (pluginFields) for (var prop in pluginFields) {\n            var plugin = pluginFields[prop],\n              state = plugin.spec.state;\n            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n              return;\n            }\n          }\n          instance[field.name] = field.init(config, instance);\n        }\n      });\n      return instance;\n    }\n  }]);\n  return EditorState;\n}();\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) val = val.bind(self);else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nvar Plugin = /*#__PURE__*/function () {\n  /**\n  Create a plugin.\n  */\n  function Plugin(\n  /**\n  The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n  */\n  spec) {\n    _classCallCheck(this, Plugin);\n    this.spec = spec;\n    /**\n    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n    */\n    this.props = {};\n    if (spec.props) bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  /**\n  Extract the plugin's state field from an editor state.\n  */\n  _createClass(Plugin, [{\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n  return Plugin;\n}();\nvar keys = Object.create(null);\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nvar PluginKey = /*#__PURE__*/function () {\n  /**\n  Create a plugin key.\n  */\n  function PluginKey() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"key\";\n    _classCallCheck(this, PluginKey);\n    this.key = createKey(name);\n  }\n  /**\n  Get the active plugin with this key, if any, from an editor\n  state.\n  */\n  _createClass(PluginKey, [{\n    key: \"get\",\n    value: function get(state) {\n      return state.config.pluginsByKey[this.key];\n    }\n    /**\n    Get the plugin's state from an editor state.\n    */\n  }, {\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n  return PluginKey;\n}();\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };","map":{"version":3,"names":["Slice","Fragment","Mark","Node","ReplaceStep","ReplaceAroundStep","Transform","classesById","Object","create","Selection","$anchor","$head","ranges","_classCallCheck","SelectionRange","min","max","_createClass","key","get","pos","$from","$to","i","length","value","content","doc","slice","from","to","replace","tr","arguments","undefined","empty","lastNode","lastChild","lastParent","openEnd","mapFrom","steps","_ranges$_i","mapping","replaceRange","map","selectionToInsertionEnd","isInline","isTextblock","replaceWith","node","_ranges$i","deleteRange","replaceRangeWith","getBookmark","TextSelection","between","findFrom","$pos","dir","textOnly","inner","parent","inlineContent","findSelectionIn","index","depth","found","before","after","near","bias","AllSelection","atStart","atEnd","size","childCount","fromJSON","json","type","RangeError","cls","concat","jsonID","id","selectionClass","prototype","visible","warnedAboutTextSelection","checkTextSelection","console","name","_Selection","_inherits","_super","_createSuper","call","resolve","head","anchor","_get","_getPrototypeOf","marks","marksAcross","ensureMarks","eq","other","TextBookmark","toJSON","dPos","NodeSelection","_Selection2","_super2","_this","nodeAfter","$end","nodeSize","_mapping$mapResult","mapResult","deleted","NodeBookmark","isSelectable","isText","spec","selectable","_mapping$mapResult2","_Selection3","_super3","delete","sel","selection","setSelection","AllBookmark","text","child","isAtom","startLen","last","step","maps","end","forEach","_from","_to","_newFrom","newTo","UPDATED_SEL","UPDATED_MARKS","UPDATED_SCROLL","Transaction","_Transform","_super4","state","_this2","curSelectionFor","updated","meta","time","Date","now","curSelection","storedMarks","setStoredMarks","sameSet","addStoredMark","mark","addToSet","removeStoredMark","removeFromSet","addStep","setTime","replaceSelection","replaceSelectionWith","inheritMarks","none","deleteSelection","insertText","schema","setMeta","getMeta","_","scrollIntoView","bind","f","self","FieldDesc","desc","init","apply","baseFields","config","topNodeType","createAndFill","instance","_marks","_old","$cursor","prev","scrolledIntoView","Configuration","plugins","_this3","pluginsByKey","fields","plugin","push","EditorState","applyTransaction","filterTransaction","ignore","rootTr","transactions","trs","newState","applyInner","seen","haveNew","appendTransaction","n","oldState","j","newInstance","field","reconfigure","$config","hasOwnProperty","pluginFields","result","m","prop","markFromJSON","bindProps","obj","target","val","Function","Plugin","props","createKey","getState","keys","PluginKey"],"sources":["/Users/jiinpark/seb44_pre_006/node_modules/prosemirror-state/dist/index.js"],"sourcesContent":["import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection's head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError(\"Invalid input for Selection.fromJSON\");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = Slice.empty) {\n        super.replace(tr, content);\n        if (content == Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new Slice(Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\")\n            throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = Slice.empty) {\n        if (content == Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: \"all\" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == \"string\" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc(\"doc\", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc(\"selection\", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc(\"storedMarks\", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta(\"appendedTransaction\", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError(\"Applying a mismatched transaction\");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == 'object')\n            for (let prop in pluginFields) {\n                if (prop == \"doc\" || prop == \"selection\")\n                    throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n        if (!config.schema)\n            throw new RangeError(\"Required config field 'schema' missing\");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == \"doc\") {\n                instance.doc = Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == \"selection\") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == \"storedMarks\") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == \"handleDOMEvents\")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}