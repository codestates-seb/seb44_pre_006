{"ast":null,"code":"import _createClass from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nvar InputRule = /*#__PURE__*/_createClass(\n// :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n/**\nCreate an input rule. The rule applies when the user typed\nsomething and the text directly in front of the cursor matches\n`match`, which should end with `$`.\n\nThe `handler` can be a string, in which case the matched text, or\nthe first matched group in the regexp, is replaced by that\nstring.\n\nOr a it can be a function, which will be called with the match\narray produced by\n[`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\nas well as the start and end of the matched range, and which can\nreturn a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\nrule's effect, or null to indicate the input was not handled.\n*/\nfunction InputRule(\n/**\n@internal\n*/\nmatch, handler) {\n  _classCallCheck(this, InputRule);\n  this.match = match;\n  this.match = match;\n  this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n});\nfunction stringHandler(string) {\n  return function (state, match, start, end) {\n    var insert = string;\n    if (match[1]) {\n      var offset = match[0].lastIndexOf(match[1]);\n      insert += match[0].slice(offset + match[1].length);\n      start += offset;\n      var cutOff = start - end;\n      if (cutOff > 0) {\n        insert = match[0].slice(offset - cutOff, offset) + insert;\n        start = end;\n      }\n    }\n    return state.tr.insertText(insert, start, end);\n  };\n}\nvar MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules(_ref) {\n  var rules = _ref.rules;\n  var plugin = new Plugin({\n    state: {\n      init: function init() {\n        return null;\n      },\n      apply: function apply(tr, prev) {\n        var stored = tr.getMeta(this);\n        if (stored) return stored;\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput: function handleTextInput(view, from, to, text) {\n        return run(view, from, to, text, rules, plugin);\n      },\n      handleDOMEvents: {\n        compositionend: function compositionend(view) {\n          setTimeout(function () {\n            var $cursor = view.state.selection.$cursor;\n            if ($cursor) run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n          });\n        }\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n  if (view.composing) return false;\n  var state = view.state,\n    $from = state.doc.resolve(from);\n  if ($from.parent.type.spec.code) return false;\n  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\uFFFC\") + text;\n  for (var i = 0; i < rules.length; i++) {\n    var match = rules[i].match.exec(textBefore);\n    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n    if (!tr) continue;\n    view.dispatch(tr.setMeta(plugin, {\n      transform: tr,\n      from: from,\n      to: to,\n      text: text\n    }));\n    return true;\n  }\n  return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nvar undoInputRule = function undoInputRule(state, dispatch) {\n  var plugins = state.plugins;\n  for (var i = 0; i < plugins.length; i++) {\n    var plugin = plugins[i],\n      undoable = void 0;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        var tr = state.tr,\n          toUndo = undoable.transform;\n        for (var j = toUndo.steps.length - 1; j >= 0; j--) tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        if (undoable.text) {\n          var marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n        dispatch(tr);\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nvar emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nvar ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nvar openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nvar closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nvar openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nvar closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nvar smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType) {\n  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var joinPredicate = arguments.length > 3 ? arguments[3] : undefined;\n  return new InputRule(regexp, function (state, match, start, end) {\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    var tr = state.tr.delete(start, end);\n    var $start = tr.doc.resolve(start),\n      range = $start.blockRange(),\n      wrapping = range && findWrapping(range, nodeType, attrs);\n    if (!wrapping) return null;\n    tr.wrap(range, wrapping);\n    var before = tr.doc.resolve(start - 1).nodeBefore;\n    if (before && before.type == nodeType && canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);\n    return tr;\n  });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType) {\n  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return new InputRule(regexp, function (state, match, start, end) {\n    var $start = state.doc.resolve(start);\n    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;\n    return state.tr.delete(start, end).setBlockType(start, start, nodeType, attrs);\n  });\n}\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };","map":{"version":3,"names":["Plugin","findWrapping","canJoin","InputRule","_createClass","match","handler","_classCallCheck","stringHandler","string","state","start","end","insert","offset","lastIndexOf","slice","length","cutOff","tr","insertText","MAX_MATCH","inputRules","_ref","rules","plugin","init","apply","prev","stored","getMeta","selectionSet","docChanged","props","handleTextInput","view","from","to","text","run","handleDOMEvents","compositionend","setTimeout","$cursor","selection","pos","isInputRules","composing","$from","doc","resolve","parent","type","spec","code","textBefore","textBetween","Math","max","parentOffset","i","exec","dispatch","setMeta","transform","undoInputRule","plugins","undoable","getState","toUndo","j","steps","step","invert","docs","marks","replaceWith","schema","delete","emDash","ellipsis","openDoubleQuote","closeDoubleQuote","openSingleQuote","closeSingleQuote","smartQuotes","wrappingInputRule","regexp","nodeType","getAttrs","arguments","undefined","joinPredicate","attrs","Function","$start","range","blockRange","wrapping","wrap","before","nodeBefore","join","textblockTypeInputRule","node","canReplaceWith","index","indexAfter","setBlockType"],"sources":["/Users/jiinpark/seb44_pre_006/node_modules/prosemirror-inputrules/dist/index.js"],"sourcesContent":["import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    if ($from.parent.type.spec.code)\n        return false;\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let match = rules[i].match.exec(textBefore);\n        let tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        view.dispatch(tr.setMeta(plugin, { transform: tr, from, to, text }));\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}