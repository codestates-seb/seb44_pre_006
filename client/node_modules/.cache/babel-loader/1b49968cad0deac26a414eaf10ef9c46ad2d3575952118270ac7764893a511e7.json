{"ast":null,"code":"import _classCallCheck from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/jiinpark/seb44_pre_006/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nvar max_empty_items = 500;\nvar Branch = /*#__PURE__*/function () {\n  function Branch(items, eventCount) {\n    _classCallCheck(this, Branch);\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  // Pop the latest event off the branch's history and apply it\n  // to a document transform.\n  _createClass(Branch, [{\n    key: \"popEvent\",\n    value: function popEvent(state, preserveItems) {\n      var _this = this;\n      if (this.eventCount == 0) return null;\n      var end = this.items.length;\n      for (;; end--) {\n        var next = this.items.get(end - 1);\n        if (next.selection) {\n          --end;\n          break;\n        }\n      }\n      var remap, mapFrom;\n      if (preserveItems) {\n        remap = this.remapping(end, this.items.length);\n        mapFrom = remap.maps.length;\n      }\n      var transform = state.tr;\n      var selection, remaining;\n      var addAfter = [],\n        addBefore = [];\n      this.items.forEach(function (item, i) {\n        if (!item.step) {\n          if (!remap) {\n            remap = _this.remapping(end, i + 1);\n            mapFrom = remap.maps.length;\n          }\n          mapFrom--;\n          addBefore.push(item);\n          return;\n        }\n        if (remap) {\n          addBefore.push(new Item(item.map));\n          var step = item.step.map(remap.slice(mapFrom)),\n            map;\n          if (step && transform.maybeStep(step).doc) {\n            map = transform.mapping.maps[transform.mapping.maps.length - 1];\n            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n          }\n          mapFrom--;\n          if (map) remap.appendMap(map, mapFrom);\n        } else {\n          transform.maybeStep(item.step);\n        }\n        if (item.selection) {\n          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);\n          return false;\n        }\n      }, this.items.length, 0);\n      return {\n        remaining: remaining,\n        transform: transform,\n        selection: selection\n      };\n    }\n    // Create a new branch with the given transform added.\n  }, {\n    key: \"addTransform\",\n    value: function addTransform(transform, selection, histOptions, preserveItems) {\n      var newItems = [],\n        eventCount = this.eventCount;\n      var oldItems = this.items,\n        lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n      for (var i = 0; i < transform.steps.length; i++) {\n        var step = transform.steps[i].invert(transform.docs[i]);\n        var item = new Item(transform.mapping.maps[i], step, selection),\n          merged = void 0;\n        if (merged = lastItem && lastItem.merge(item)) {\n          item = merged;\n          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);\n        }\n        newItems.push(item);\n        if (selection) {\n          eventCount++;\n          selection = undefined;\n        }\n        if (!preserveItems) lastItem = item;\n      }\n      var overflow = eventCount - histOptions.depth;\n      if (overflow > DEPTH_OVERFLOW) {\n        oldItems = cutOffEvents(oldItems, overflow);\n        eventCount -= overflow;\n      }\n      return new Branch(oldItems.append(newItems), eventCount);\n    }\n  }, {\n    key: \"remapping\",\n    value: function remapping(from, to) {\n      var maps = new Mapping();\n      this.items.forEach(function (item, i) {\n        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n        maps.appendMap(item.map, mirrorPos);\n      }, from, to);\n      return maps;\n    }\n  }, {\n    key: \"addMaps\",\n    value: function addMaps(array) {\n      if (this.eventCount == 0) return this;\n      return new Branch(this.items.append(array.map(function (map) {\n        return new Item(map);\n      })), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n  }, {\n    key: \"rebased\",\n    value: function rebased(rebasedTransform, rebasedCount) {\n      if (!this.eventCount) return this;\n      var rebasedItems = [],\n        start = Math.max(0, this.items.length - rebasedCount);\n      var mapping = rebasedTransform.mapping;\n      var newUntil = rebasedTransform.steps.length;\n      var eventCount = this.eventCount;\n      this.items.forEach(function (item) {\n        if (item.selection) eventCount--;\n      }, start);\n      var iRebased = rebasedCount;\n      this.items.forEach(function (item) {\n        var pos = mapping.getMirror(--iRebased);\n        if (pos == null) return;\n        newUntil = Math.min(newUntil, pos);\n        var map = mapping.maps[pos];\n        if (item.step) {\n          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n          if (selection) eventCount++;\n          rebasedItems.push(new Item(map, step, selection));\n        } else {\n          rebasedItems.push(new Item(map));\n        }\n      }, start);\n      var newMaps = [];\n      for (var i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));\n      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n      var branch = new Branch(items, eventCount);\n      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n      return branch;\n    }\n  }, {\n    key: \"emptyItemCount\",\n    value: function emptyItemCount() {\n      var count = 0;\n      this.items.forEach(function (item) {\n        if (!item.step) count++;\n      });\n      return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n  }, {\n    key: \"compress\",\n    value: function compress() {\n      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var remap = this.remapping(0, upto),\n        mapFrom = remap.maps.length;\n      var items = [],\n        events = 0;\n      this.items.forEach(function (item, i) {\n        if (i >= upto) {\n          items.push(item);\n          if (item.selection) events++;\n        } else if (item.step) {\n          var step = item.step.map(remap.slice(mapFrom)),\n            map = step && step.getMap();\n          mapFrom--;\n          if (map) remap.appendMap(map, mapFrom);\n          if (step) {\n            var selection = item.selection && item.selection.map(remap.slice(mapFrom));\n            if (selection) events++;\n            var newItem = new Item(map.invert(), step, selection),\n              merged,\n              last = items.length - 1;\n            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);\n          }\n        } else if (item.map) {\n          mapFrom--;\n        }\n      }, this.items.length, 0);\n      return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n  }]);\n  return Branch;\n}();\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n  var cutPoint;\n  items.forEach(function (item, i) {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nvar Item = /*#__PURE__*/function () {\n  function Item(\n  // The (forward) step map for this item.\n  map,\n  // The inverted step\n  step,\n  // If this is non-null, this item is the start of a group, and\n  // this selection is the starting selection for the group (the one\n  // that was active before the first step was applied)\n  selection,\n  // If this item is the inverse of a previous mapping on the stack,\n  // this points at the inverse's offset\n  mirrorOffset) {\n    _classCallCheck(this, Item);\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  _createClass(Item, [{\n    key: \"merge\",\n    value: function merge(other) {\n      if (this.step && other.step && !other.selection) {\n        var step = other.step.merge(this.step);\n        if (step) return new Item(step.getMap().invert(), step, this.selection);\n      }\n    }\n  }]);\n  return Item;\n}(); // The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nvar HistoryState = /*#__PURE__*/_createClass(function HistoryState(done, undone, prevRanges, prevTime, prevComposition) {\n  _classCallCheck(this, HistoryState);\n  this.done = done;\n  this.undone = undone;\n  this.prevRanges = prevRanges;\n  this.prevTime = prevTime;\n  this.prevComposition = prevComposition;\n});\nvar DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n  var historyTr = tr.getMeta(historyKey),\n    rebased;\n  if (historyTr) return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);\n  var appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    // Group transforms that occur in quick succession into one event.\n    var composition = tr.getMeta(\"composition\");\n    var newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    // Used by the collab module to tell the history that some of its\n    // content has been rebased.\n    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  } else {\n    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges) return false;\n  if (!transform.docChanged) return true;\n  var adjacent = false;\n  transform.mapping.maps[0].forEach(function (start, end) {\n    for (var i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(map) {\n  var result = [];\n  map.forEach(function (_from, _to, from, to) {\n    return result.push(from, to);\n  });\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges) return null;\n  var result = [];\n  for (var i = 0; i < ranges.length; i += 2) {\n    var from = mapping.map(ranges[i], 1),\n      to = mapping.map(ranges[i + 1], -1);\n    if (from <= to) result.push(from, to);\n  }\n  return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n  var preserveItems = mustPreserveItems(state);\n  var histOptions = historyKey.get(state).spec.config;\n  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n  if (!pop) return;\n  var selection = pop.selection.resolve(pop.transform.doc);\n  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n    redo: redo,\n    historyState: newHist\n  }).scrollIntoView());\n}\nvar cachedPreserveItems = false,\n  cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n  var plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (var i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {\n      cachedPreserveItems = true;\n      break;\n    }\n  }\n  return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nvar historyKey = new PluginKey(\"history\");\nvar closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new Plugin({\n    key: historyKey,\n    state: {\n      init: function init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n      },\n      apply: function apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config: config,\n    props: {\n      handleDOMEvents: {\n        beforeinput: function beforeinput(view, e) {\n          var inputType = e.inputType;\n          var command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command) return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nvar undo = function undo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, false);\n  return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nvar redo = function redo(state, dispatch) {\n  var hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0) return false;\n  if (dispatch) histTransaction(hist, state, dispatch, true);\n  return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n  var hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };","map":{"version":3,"names":["RopeSequence","Mapping","PluginKey","Plugin","max_empty_items","Branch","items","eventCount","_classCallCheck","_createClass","key","value","popEvent","state","preserveItems","_this","end","length","next","get","selection","remap","mapFrom","remapping","maps","transform","tr","remaining","addAfter","addBefore","forEach","item","i","step","push","Item","map","slice","maybeStep","doc","mapping","undefined","appendMap","append","reverse","concat","addTransform","histOptions","newItems","oldItems","lastItem","steps","invert","docs","merged","merge","pop","overflow","depth","DEPTH_OVERFLOW","cutOffEvents","from","to","mirrorPos","mirrorOffset","addMaps","array","rebased","rebasedTransform","rebasedCount","rebasedItems","start","Math","max","newUntil","iRebased","pos","getMirror","min","newMaps","branch","emptyItemCount","compress","count","upto","arguments","events","getMap","newItem","last","empty","n","cutPoint","other","HistoryState","done","undone","prevRanges","prevTime","prevComposition","applyTransaction","history","options","historyTr","getMeta","historyKey","historyState","closeHistoryKey","appended","redo","mustPreserveItems","rangesFor","composition","newGroup","time","newGroupDelay","isAdjacentTo","mapRanges","getBookmark","docChanged","adjacent","result","_from","_to","ranges","histTransaction","dispatch","spec","config","resolve","added","newHist","setSelection","setMeta","scrollIntoView","cachedPreserveItems","cachedPreserveItemsPlugins","plugins","historyPreserveItems","closeHistory","init","apply","hist","props","handleDOMEvents","beforeinput","view","e","inputType","command","undo","preventDefault","getState","undoDepth","redoDepth"],"sources":["/Users/jiinpark/seb44_pre_006/node_modules/prosemirror-history/dist/index.js"],"sourcesContent":["import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = (state, dispatch) => {\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0)\n        return false;\n    if (dispatch)\n        histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, undo, undoDepth };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}