{"ast":null,"code":"import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n  /**\n  Initialize a selection with the head and anchor and ranges. If no\n  ranges are given, constructs a single range across `$anchor` and\n  `$head`.\n  */\n  constructor(\n  /**\n  The resolved anchor of the selection (the side that stays in\n  place when the selection is modified).\n  */\n  $anchor,\n  /**\n  The resolved head of the selection (the side that moves when\n  the selection is modified).\n  */\n  $head, ranges) {\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  /**\n  The selection's anchor, as an unresolved position.\n  */\n  get anchor() {\n    return this.$anchor.pos;\n  }\n  /**\n  The selection's head.\n  */\n  get head() {\n    return this.$head.pos;\n  }\n  /**\n  The lower bound of the selection's main range.\n  */\n  get from() {\n    return this.$from.pos;\n  }\n  /**\n  The upper bound of the selection's main range.\n  */\n  get to() {\n    return this.$to.pos;\n  }\n  /**\n  The resolved lower  bound of the selection's main range.\n  */\n  get $from() {\n    return this.ranges[0].$from;\n  }\n  /**\n  The resolved upper bound of the selection's main range.\n  */\n  get $to() {\n    return this.ranges[0].$to;\n  }\n  /**\n  Indicates whether the selection contains any content.\n  */\n  get empty() {\n    let ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;\n    return true;\n  }\n  /**\n  Get the content of this selection as a slice.\n  */\n  content() {\n    return this.$from.doc.slice(this.from, this.to, true);\n  }\n  /**\n  Replace the selection with a slice or, if no slice is given,\n  delete the selection. Will append to the given transaction.\n  */\n  replace(tr) {\n    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n    // Put the new selection at the position after the inserted\n    // content. When that ended in an inline node, search backwards,\n    // to get the position after that node. If not, search forward.\n    let lastNode = content.content.lastChild,\n      lastParent = null;\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode;\n      lastNode = lastNode.lastChild;\n    }\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n      if (i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n    }\n  }\n  /**\n  Replace the selection with the given node, appending the changes\n  to the given transaction.\n  */\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let {\n          $from,\n          $to\n        } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      let from = mapping.map($from.pos),\n        to = mapping.map($to.pos);\n      if (i) {\n        tr.deleteRange(from, to);\n      } else {\n        tr.replaceRangeWith(from, to, node);\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n      }\n    }\n  }\n  /**\n  Find a valid cursor or leaf node selection starting at the given\n  position and searching back if `dir` is negative, and forward if\n  positive. When `textOnly` is true, only consider cursor\n  selections. Will return null when no valid selection position is\n  found.\n  */\n  static findFrom($pos, dir) {\n    let textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n    if (inner) return inner;\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n      if (found) return found;\n    }\n    return null;\n  }\n  /**\n  Find a valid cursor or leaf node selection near the given\n  position. Searches forward first by default, but if `bias` is\n  negative, it will search backwards first.\n  */\n  static near($pos) {\n    let bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n  }\n  /**\n  Find the cursor or leaf node selection closest to the start of\n  the given document. Will return an\n  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n  exists.\n  */\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n  }\n  /**\n  Find the cursor or leaf node selection closest to the end of the\n  given document.\n  */\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n  }\n  /**\n  Deserialize the JSON representation of a selection. Must be\n  implemented for custom classes (as a static class method).\n  */\n  static fromJSON(doc, json) {\n    if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\");\n    let cls = classesById[json.type];\n    if (!cls) throw new RangeError(`No selection type ${json.type} defined`);\n    return cls.fromJSON(doc, json);\n  }\n  /**\n  To be able to deserialize selections from JSON, custom selection\n  classes must register themselves with an ID string, so that they\n  can be disambiguated. Try to pick something that's unlikely to\n  clash with classes from other modules.\n  */\n  static jsonID(id, selectionClass) {\n    if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n    classesById[id] = selectionClass;\n    selectionClass.prototype.jsonID = id;\n    return selectionClass;\n  }\n  /**\n  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n  which is a value that can be mapped without having access to a\n  current document, and later resolved to a real selection for a\n  given document again. (This is used mostly by the history to\n  track and restore old selections.) The default implementation of\n  this method just converts the selection to a text selection and\n  returns the bookmark for that.\n  */\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark();\n  }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n  /**\n  Create a range.\n  */\n  constructor(\n  /**\n  The lower bound of the range.\n  */\n  $from,\n  /**\n  The upper bound of the range.\n  */\n  $to) {\n    this.$from = $from;\n    this.$to = $to;\n  }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n  /**\n  Construct a text selection between the given points.\n  */\n  constructor($anchor) {\n    let $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    super($anchor, $head);\n  }\n  /**\n  Returns a resolved position if this is a cursor selection (an\n  empty text selection), and null otherwise.\n  */\n  get $cursor() {\n    return this.$anchor.pos == this.$head.pos ? this.$head : null;\n  }\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent) return Selection.near($head);\n    let $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n  }\n  replace(tr) {\n    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n    super.replace(tr, content);\n    if (content == Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to);\n      if (marks) tr.ensureMarks(marks);\n    }\n  }\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n  }\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head);\n  }\n  toJSON() {\n    return {\n      type: \"text\",\n      anchor: this.anchor,\n      head: this.head\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  /**\n  Create a text selection from non-resolved positions.\n  */\n  static create(doc, anchor) {\n    let head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;\n    let $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n  }\n  /**\n  Return a text selection that spans the given positions or, if\n  they aren't text positions, find a text selection near them.\n  `bias` determines whether the method searches forward (default)\n  or backwards (negative number) first. Will fall back to calling\n  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n  doesn't contain a valid text position.\n  */\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found) $head = found.$head;else return Selection.near($head, bias);\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;\n      }\n    }\n    return new TextSelection($anchor, $head);\n  }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n  }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n  /**\n  Create a node selection. Does not verify the validity of its\n  argument.\n  */\n  constructor($pos) {\n    let node = $pos.nodeAfter;\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    super($pos, $end);\n    this.node = node;\n  }\n  map(doc, mapping) {\n    let {\n      deleted,\n      pos\n    } = mapping.mapResult(this.anchor);\n    let $pos = doc.resolve(pos);\n    if (deleted) return Selection.near($pos);\n    return new NodeSelection($pos);\n  }\n  content() {\n    return new Slice(Fragment.from(this.node), 0, 0);\n  }\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor;\n  }\n  toJSON() {\n    return {\n      type: \"node\",\n      anchor: this.anchor\n    };\n  }\n  getBookmark() {\n    return new NodeBookmark(this.anchor);\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\") throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n    return new NodeSelection(doc.resolve(json.anchor));\n  }\n  /**\n  Create a node selection from non-resolved positions.\n  */\n  static create(doc, from) {\n    return new NodeSelection(doc.resolve(from));\n  }\n  /**\n  Determines whether the given node may be selected as a node\n  selection.\n  */\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false;\n  }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n  map(mapping) {\n    let {\n      deleted,\n      pos\n    } = mapping.mapResult(this.anchor);\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor),\n      node = $pos.nodeAfter;\n    if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);\n    return Selection.near($pos);\n  }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n  /**\n  Create an all-selection over the given document.\n  */\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size));\n  }\n  replace(tr) {\n    let content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Slice.empty;\n    if (content == Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      let sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection)) tr.setSelection(sel);\n    } else {\n      super.replace(tr, content);\n    }\n  }\n  toJSON() {\n    return {\n      type: \"all\"\n    };\n  }\n  /**\n  @internal\n  */\n  static fromJSON(doc) {\n    return new AllSelection(doc);\n  }\n  map(doc) {\n    return new AllSelection(doc);\n  }\n  eq(other) {\n    return other instanceof AllSelection;\n  }\n  getBookmark() {\n    return AllBookmark;\n  }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n  map() {\n    return this;\n  },\n  resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir) {\n  let text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (node.inlineContent) return TextSelection.create(doc, pos);\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i);\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1;\n  if (last < startLen) return;\n  let step = tr.steps[last];\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) return;\n  let map = tr.mapping.maps[last],\n    end;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end == null) end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst UPDATED_SEL = 1,\n  UPDATED_MARKS = 2,\n  UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends Transform {\n  /**\n  @internal\n  */\n  constructor(state) {\n    super(state.doc);\n    // The step count for which the current selection is valid.\n    this.curSelectionFor = 0;\n    // Bitfield to track which aspects of the state were updated by\n    // this transaction.\n    this.updated = 0;\n    // Object used to store metadata properties for the transaction.\n    this.meta = Object.create(null);\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    this.storedMarks = state.storedMarks;\n  }\n  /**\n  The transaction's current selection. This defaults to the editor\n  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n  transaction, but can be overwritten with\n  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n  */\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection;\n  }\n  /**\n  Update the transaction's current selection. Will determine the\n  selection that the editor gets when the transaction is applied.\n  */\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc) throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this;\n  }\n  /**\n  Whether the selection was explicitly updated by this transaction.\n  */\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0;\n  }\n  /**\n  Set the current stored marks.\n  */\n  setStoredMarks(marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this;\n  }\n  /**\n  Make sure the current stored marks or, if that is null, the marks\n  at the selection, match the given set of marks. Does nothing if\n  this is already the case.\n  */\n  ensureMarks(marks) {\n    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);\n    return this;\n  }\n  /**\n  Add a mark to the set of stored marks.\n  */\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  /**\n  Remove a mark or mark type from the set of stored marks.\n  */\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  /**\n  Whether the stored marks were explicitly set for this transaction.\n  */\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0;\n  }\n  /**\n  @internal\n  */\n  addStep(step, doc) {\n    super.addStep(step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  }\n  /**\n  Update the timestamp for the transaction.\n  */\n  setTime(time) {\n    this.time = time;\n    return this;\n  }\n  /**\n  Replace the current selection with the given slice.\n  */\n  replaceSelection(slice) {\n    this.selection.replace(this, slice);\n    return this;\n  }\n  /**\n  Replace the selection with the given node. When `inheritMarks` is\n  true and the content is inline, it inherits the marks from the\n  place where it is inserted.\n  */\n  replaceSelectionWith(node) {\n    let inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let selection = this.selection;\n    if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));\n    selection.replaceWith(this, node);\n    return this;\n  }\n  /**\n  Delete the selection.\n  */\n  deleteSelection() {\n    this.selection.replace(this);\n    return this;\n  }\n  /**\n  Replace the given range, or the selection if no range is given,\n  with a text node containing the given string.\n  */\n  insertText(text, from, to) {\n    let schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text) return this.deleteSelection();\n      return this.replaceSelectionWith(schema.text(text), true);\n    } else {\n      if (to == null) to = from;\n      to = to == null ? from : to;\n      if (!text) return this.deleteRange(from, to);\n      let marks = this.storedMarks;\n      if (!marks) {\n        let $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));\n      return this;\n    }\n  }\n  /**\n  Store a metadata property in this transaction, keyed either by\n  name or by plugin.\n  */\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this;\n  }\n  /**\n  Retrieve a metadata property for a given name or plugin.\n  */\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key];\n  }\n  /**\n  Returns true if this transaction doesn't contain any metadata,\n  and can thus safely be extended.\n  */\n  get isGeneric() {\n    for (let _ in this.meta) return false;\n    return true;\n  }\n  /**\n  Indicate that the editor should scroll the selection into view\n  when updated to the state produced by this transaction.\n  */\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL;\n    return this;\n  }\n  /**\n  True when this transaction has had `scrollIntoView` called on it.\n  */\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0;\n  }\n}\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name;\n    this.init = bind(desc.init, self);\n    this.apply = bind(desc.apply, self);\n  }\n}\nconst baseFields = [new FieldDesc(\"doc\", {\n  init(config) {\n    return config.doc || config.schema.topNodeType.createAndFill();\n  },\n  apply(tr) {\n    return tr.doc;\n  }\n}), new FieldDesc(\"selection\", {\n  init(config, instance) {\n    return config.selection || Selection.atStart(instance.doc);\n  },\n  apply(tr) {\n    return tr.selection;\n  }\n}), new FieldDesc(\"storedMarks\", {\n  init(config) {\n    return config.storedMarks || null;\n  },\n  apply(tr, _marks, _old, state) {\n    return state.selection.$cursor ? tr.storedMarks : null;\n  }\n}), new FieldDesc(\"scrollToSelection\", {\n  init() {\n    return 0;\n  },\n  apply(tr, prev) {\n    return tr.scrolledIntoView ? prev + 1 : prev;\n  }\n})];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema;\n    this.plugins = [];\n    this.pluginsByKey = Object.create(null);\n    this.fields = baseFields.slice();\n    if (plugins) plugins.forEach(plugin => {\n      if (this.pluginsByKey[plugin.key]) throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n      this.plugins.push(plugin);\n      this.pluginsByKey[plugin.key] = plugin;\n      if (plugin.spec.state) this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n    });\n  }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  config) {\n    this.config = config;\n  }\n  /**\n  The schema of the state's document.\n  */\n  get schema() {\n    return this.config.schema;\n  }\n  /**\n  The plugins that are active in this state.\n  */\n  get plugins() {\n    return this.config.plugins;\n  }\n  /**\n  Apply the given transaction to produce a new state.\n  */\n  apply(tr) {\n    return this.applyTransaction(tr).state;\n  }\n  /**\n  @internal\n  */\n  filterTransaction(tr) {\n    let ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n    for (let i = 0; i < this.config.plugins.length; i++) if (i != ignore) {\n      let plugin = this.config.plugins[i];\n      if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;\n    }\n    return true;\n  }\n  /**\n  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n  returns the precise transactions that were applied (which might\n  be influenced by the [transaction\n  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n  plugins) along with the new state.\n  */\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr)) return {\n      state: this,\n      transactions: []\n    };\n    let trs = [rootTr],\n      newState = this.applyInner(rootTr),\n      seen = null;\n    // This loop repeatedly gives plugins a chance to respond to\n    // transactions as new transactions are added, making sure to only\n    // pass the transactions the plugin did not see before.\n    for (;;) {\n      let haveNew = false;\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i];\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0,\n            oldState = seen ? seen[i].state : this;\n          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr);\n            if (!seen) {\n              seen = [];\n              for (let j = 0; j < this.config.plugins.length; j++) seen.push(j < i ? {\n                state: newState,\n                n: trs.length\n              } : {\n                state: this,\n                n: 0\n              });\n            }\n            trs.push(tr);\n            newState = newState.applyInner(tr);\n            haveNew = true;\n          }\n          if (seen) seen[i] = {\n            state: newState,\n            n: trs.length\n          };\n        }\n      }\n      if (!haveNew) return {\n        state: newState,\n        transactions: trs\n      };\n    }\n  }\n  /**\n  @internal\n  */\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\");\n    let newInstance = new EditorState(this.config),\n      fields = this.config.fields;\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n    }\n    return newInstance;\n  }\n  /**\n  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n  */\n  get tr() {\n    return new Transaction(this);\n  }\n  /**\n  Create a new state.\n  */\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n    let instance = new EditorState($config);\n    for (let i = 0; i < $config.fields.length; i++) instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n    return instance;\n  }\n  /**\n  Create a new state based on this one, but with an adjusted set\n  of active plugins. State fields that exist in both sets of\n  plugins are kept unchanged. Those that no longer exist are\n  dropped, and those that are new are initialized using their\n  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n  configuration object..\n  */\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins);\n    let fields = $config.fields,\n      instance = new EditorState($config);\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name;\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n    }\n    return instance;\n  }\n  /**\n  Serialize this state to JSON. If you want to serialize the state\n  of plugins, pass an object mapping property names to use in the\n  resulting JSON object to plugin objects. The argument may also be\n  a string or number, in which case it is ignored, to support the\n  way `JSON.stringify` calls `toString` methods.\n  */\n  toJSON(pluginFields) {\n    let result = {\n      doc: this.doc.toJSON(),\n      selection: this.selection.toJSON()\n    };\n    if (this.storedMarks) result.storedMarks = this.storedMarks.map(m => m.toJSON());\n    if (pluginFields && typeof pluginFields == 'object') for (let prop in pluginFields) {\n      if (prop == \"doc\" || prop == \"selection\") throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n      let plugin = pluginFields[prop],\n        state = plugin.spec.state;\n      if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n    }\n    return result;\n  }\n  /**\n  Deserialize a JSON representation of a state. `config` should\n  have at least a `schema` field, and should contain array of\n  plugins to initialize the state with. `pluginFields` can be used\n  to deserialize the state of plugins, by associating plugin\n  instances with the property names they use in the JSON object.\n  */\n  static fromJSON(config, json, pluginFields) {\n    if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n    if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\");\n    let $config = new Configuration(config.schema, config.plugins);\n    let instance = new EditorState($config);\n    $config.fields.forEach(field => {\n      if (field.name == \"doc\") {\n        instance.doc = Node.fromJSON(config.schema, json.doc);\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection);\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n      } else {\n        if (pluginFields) for (let prop in pluginFields) {\n          let plugin = pluginFields[prop],\n            state = plugin.spec.state;\n          if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n            return;\n          }\n        }\n        instance[field.name] = field.init(config, instance);\n      }\n    });\n    return instance;\n  }\n}\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop];\n    if (val instanceof Function) val = val.bind(self);else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n  /**\n  Create a plugin.\n  */\n  constructor(\n  /**\n  The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n  */\n  spec) {\n    this.spec = spec;\n    /**\n    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n    */\n    this.props = {};\n    if (spec.props) bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  /**\n  Extract the plugin's state field from an editor state.\n  */\n  getState(state) {\n    return state[this.key];\n  }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n  /**\n  Create a plugin key.\n  */\n  constructor() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"key\";\n    this.key = createKey(name);\n  }\n  /**\n  Get the active plugin with this key, if any, from an editor\n  state.\n  */\n  get(state) {\n    return state.config.pluginsByKey[this.key];\n  }\n  /**\n  Get the plugin's state from an editor state.\n  */\n  getState(state) {\n    return state[this.key];\n  }\n}\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}